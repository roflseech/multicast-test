# Общий обзор архитектуры

Используется MVP для UI, DI для композиции.

Проект разделен на ассембли, каждая из которых строго заточена на свою зону ответственности.
Не считая вспомогательных, можно выделить
### AppFlow
Композиция всех сущностей необходимых для игры, ентри поинт для старта игры в проде.
Реализовано скоупом вконтейнера, поделено на несколько хелпер статик классов чтобы не держать все в одном.
Опицонально возможно разделить все на несколько контейнеров.
Для разных типовых вещей - сделаны упрощающие методы, в целом добавление окна, или новой сейв даты делается одной строчкой.
### AssetManagement
Управление ресурсами. Другие ассембли при необходимости подгруки или поиска ресурсов должны использовать классы из AssetManagement. 
В данном проекте сразу используются Addressables, так как это готовое просто решенеи для явной загрузки/выгрузки в оперативную память.
Также это возможность вынести часть контента на CDN при лимитах в сторе или необходимости подгружать обновления.
### Configs
ScriptableObject конфиги. Содержат данные в своем формате, не могут зависеть от типов из других ассембли.
### DomainLogic
Вспомогательные классы, отвечающие за доменную логику на уровне приложения в целом.
Иными словами, абстрагируют функционал и правила по которым должны выполняться некоторые вещи - например выбор последнего уровня(посмотреть пройденные уровни, устанвоить - копипастить 2 действия в разные места нет смысла, так как эта логика может поменяться
и лучше иметь её явно заданной в одном месте)
### Game/...
Папка для ассембли конкретных игр, например в данном случае Game.CombineWordsGame
### Gameplay
Всё что связано с менедментом игр - загрузкой, стартом, ожидания победы.
### Localization
Локализация. В проекте предусмотрена абстракция, под которую легко адаптировать любой инструмент для локализации
### SaveSystem
Система сохранений. Содержит инфраструктуру, которая позволяет клиенсткому коду из других ассембли работать с сейвами через интерфейс ISaveData<T> аксимально просто
saveData.Public(data) - для обновлния данных. saveData.Value/Subscribe - для получения данных. Сохранением на диск система занимается сама, облачные сейвы интегрировать легко.
Для сериализации используется MemoryPack, так как это очень оптимизированное решение.
Возможности добавлять данные, удалять старые данные и делать миграции - есть.
### State
Модели данных для сохранения. Выделены в отделную ассмебли, чтобы сразу было легко сориентироваться, что в игре сохраняется.
### Ui.GamePresenters
Презентеры окон и виджетов
### UI.GameModels
Модели окон и виджетов
### UI.GameLayers
Агрегатор для UI, позволяющий открывать окна в разных слоях
### UIProvider
Система открытия окон, которая имеет одно активное окно и позволяет его сменять

# Структура папок и ресурсов игры
- Assets/Game код игры
- Assets/GameData - текстуры, префабы, конфиги, шрифты - любые ресурсы игры, внутри классиффицированы для удобства ориентирования в проекте
- Assets/Scenes - сцены

В конфигах используются текстовые адреса до ассетов - таким образом нет жесткой подвзяки а любой способ реферса ассетов(ассет рефы или префабы), легко править мердж конфликты и смотретьпо диффам что где и когда могло отвалиться вконфгиах
В проекте сейчас используются Addressables, некоторые из рутовых папок добавлены в адрессаблы, но не конечные ассеты по одному - это сделано для того, чтобы по адресу было сразу понятно где ассет лежит в иерархии папок

# Более подробный обзор UI
Используется MVP, где под моделью имеется в виду класс с моделью данных и бизнес логики, под презентером - монобех связывающий вью с моделью(в том числе реактивными подписками), а под вью - монобехи и UI компоненты юнити.
Таким образом, можно произвольно связывать любые префабы виджетов с любыми моделями из одного семейства.
Виджет - это основная составляюая этого UI фреймоврка, виджеты могут иметь виджеты в своем составе(например ButtonWithText) и биндить к ним соответсующие модели, за создайние или получение из фабрики которых они сами ответственны.
Для более явной работы с окнами от виджетов также наслеются Window и WindowModel с методами связанными с октрытием и закрытием.
Также есть возможность биндить как синглтон окна, так и переовать каждый раз новую модель окна в uiProvider, для которой он создаст окно.

# Более подрбный обзор архитектуры самой игры
К архитектуре самих игр в данном проекте требования ниже - игр может быть много, они могут быстро меняться и прототипироваться.
Поэтому каждая игра должна быть максимально изолированной и в приоритете иметь скорость разработки.
Предполагается, что часто используетмые части будут выностиься в Games.Common по мере необходимости, чтобы использоваться в других играх.

Уровни хзранятся в адрессаблах и грузятся по тегу, сортируются по тому к какой игре они принадлежат, проверяется нет ли пропусков.

# Возможности даьнейшего расширения
## Расширяемость системы загрузки уровней.
Уровни можно деплоить без обновления клиента - либо через адрессаблы, либо иное облачное хранение.
При необходимости можно и сменить их формат с жсона на бинарный или любой другой - достаточно сделать маппинг в соответствующую модель данных.

## Расширяемость геймплея.
В модели данных уровня содержатся все необходимые и достаточные данные для описания уровня, в данном случае для каждого уровня явно указывается размер поля, доступные кластеры и целевые слова.
Систему легко расширять - размер уровня уже предусомтрен, а дальше можно добавлять например пулы кластеров для рандомизации и в модели данных достаточно будет указать идентификатор такого пула,
или какую

## Заменяемость геймплея.
Легко добавлять новые игры со своими уровнями - пайплайн однотипный - создаем игровую логику изолированно, адаптируем под использование общего апи, регистрируем в конфигах.

Новые игры также можно потенциально деплоить полностью через адрессаблы - достаточно их перебилдить и залить на cdn, остальной код игры никак на них не будет завязан.

# Используемые технолгии
- UniRX - хороший вариант для программирования UI, так как UI часто предполагает обновление даных и ожидается визуальная реакция на это обновления.
- UniTask - таски без аллокаций, асинхронные операции так или иначе в любой игре будут, удобнее всего это делать через таски либо обсерваблы(где критично важно не потерять коллстек).
- VContainer - фреймворк для DI, сокращает написание кода, ощутимо быстрее зенжекта засчет кодогенерации. Также позволяет включить Code Stripping в medium и не включать Domain Reload - в отличии от зенжекта.
- MemoryPack - быстрая сериализация без лишних аллокаций, для хранения сейвов игрока
- ZString - стринг билдер с меньшим числом аллокаций
- Addressables - есть смысл сразщу использовать, чтобы дальше легко было мигрировать какие-то данные на CDN